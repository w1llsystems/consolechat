<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chat App</title>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
        body {
            font-family: 'Space Grotesk', sans-serif;
        }
    </style>
</head>
<body class="bg-black">
<div class="relative flex h-auto min-h-screen w-full flex-col bg-[#111811] dark group/design-root overflow-x-hidden" style='font-family: "Space Grotesk", "Noto Sans", sans-serif;'>
<div class="layout-container flex h-full grow flex-col">
<div class="px-4 py-5 sm:px-10 md:px-20 lg:px-40 flex flex-1 justify-center">
<div class="layout-content-container flex flex-col md:flex-row w-full max-w-6xl flex-1 border-2 border-gray-700 rounded-lg bg-[#0D0D0D] h-[70vh] md:h-[75vh] lg:h-[573px]">
<div class="flex-1 flex flex-col">
<div class="flex items-center justify-between bg-gray-800 px-4 py-2 rounded-t-lg">
<div class="flex items-center gap-2">
<div class="w-3 h-3 bg-red-500 rounded-full"></div>
<div class="w-3 h-3 bg-yellow-500 rounded-full"></div>
<div class="w-3 h-3 bg-green-500 rounded-full"></div>
</div>
<p class="text-gray-400 text-sm">CHAT_APP - bash <span id="status-pill" class="ml-3 inline-block rounded px-2 py-0.5 text-[10px] bg-yellow-700 text-yellow-100">connecting...</span></p>
<div class="w-12"></div>
</div>
<div class="flex-1 p-4 space-y-4 overflow-y-auto">
<div class="initial-state">
<p class="text-[#00FF00] text-base font-normal leading-normal">Connecting...</p>
<h2 class="text-[#00FF00] tracking-light text-[28px] font-bold leading-tight pt-5">Enter your nickname: _</h2>
</div>
<div class="chat-messages hidden">
<p class="text-[#00FF00] text-base font-normal leading-normal">[System]: Welcome, User_123!</p>
<p class="text-[#00FF00] text-base font-normal leading-normal">[User_123]: Hello world!</p>
</div>
</div>
<div class="p-4 border-t border-gray-700 rounded-bl-lg">
            <div class="nickname-input flex max-w-[320px] flex-wrap items-end gap-2 py-2">
                <label class="flex flex-col min-w-24 flex-1">
                    <input class="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded text-[#00FF00] focus:outline-0 focus:ring-0 border border-[#2A3B2A] bg-[#0D0D0D] focus:border-[#2A3B2A] h-10 placeholder:text-gray-500 p-[8px] text-sm font-normal leading-normal" placeholder="Your nickname" value=""/>
                </label>
            </div>
            <div class="message-input hidden flex flex-wrap items-end gap-2 py-2">
                <label class="flex flex-col flex-1">
                    <textarea class="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded text-[#00FF00] focus:outline-0 focus:ring-0 border border-[#2A3B2A] bg-[#0D0D0D] focus:border-[#2A3B2A] min-h-[64px] placeholder:text-gray-500 p-[8px] text-sm font-normal leading-normal" maxlength="80" placeholder="Type your message (max 80 chars)"></textarea>
                </label>
                <div class="flex justify-start">
                    <button class="flex min-w-[64px] max-w-[160px] cursor-pointer items-center justify-center overflow-hidden rounded h-8 px-3 bg-[#00FF00] text-black text-sm font-bold leading-normal tracking-[0.015em]" type="button">
                        <span class="truncate">Send</span>
                    </button>
                </div>
            </div>
</div>
</div>
<div class="w-full md:w-[240px] border-t-2 md:border-t-0 md:border-l-2 border-gray-700 flex flex-col">
<div class="bg-gray-800 px-4 py-2 flex items-center justify-center">
<p class="text-gray-400 text-sm">ACTIVE_USERS</p>
</div>
<div id="active-users-list" class="p-4 space-y-2 overflow-y-auto max-h-40 md:max-h-none flex-1"></div>
</div>
</div>
</div>
</div>
</div>

<script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
<script>
    // Minimal client-side anonymous chat behavior
    // - No persistence (no localStorage/sessionStorage)
    // - User supplies a nickname (optional)
    // - Messages are appended locally only
    // - When the messages container overflows, oldest messages are removed so the layout stays clean

    (function () {
        const initialStateEl = document.querySelector('.initial-state');
        const chatMessagesEl = document.querySelector('.chat-messages');
        const nicknameInput = document.querySelector('.nickname-input input');
        const messageInputWrapper = document.querySelector('.message-input');
        const messageTextarea = document.querySelector('.message-input textarea');
        const sendButton = document.querySelector('.message-input button');
        const activeUsersListEl = document.querySelector('#active-users-list');
    const statusPill = document.getElementById('status-pill');

        // Make sure button acts as button
        if (sendButton) sendButton.setAttribute('type', 'button');

        // State
        let currentIp = null;
        let ipCheckAvailable = false;
    let ably = null;
    let ablyChannel = null;
    let ablyConnected = false;
    // Track the current nickname in use (for mention highlighting)
    let currentNick = null;
    // Guards to avoid duplicate attach/subscribe
    let ablyAttached = false;
    let messageSubscribed = false;
        // Max history lines to keep
        const MAX_HISTORY = 200;

        // Helpers
        function createMessageElement(text) {
            const p = document.createElement('p');
            p.className = 'text-[#00FF00] text-base font-normal leading-normal whitespace-pre-wrap break-words';
            p.textContent = text;
            return p;
        }

        // Escape HTML to prevent injection when using innerHTML in renderMessage
        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, (ch) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            })[ch]);
        }

        function escapeRegExp(str) {
            return String(str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Format @mentions in already-escaped text. Highlights @me specially.
        function formatMentions(escapedText, myNick) {
            const re = /(^|\s)@([\w-]{1,32})\b/g;
            return escapedText.replace(re, (m, pre, name) => {
                const isMe = myNick && name.toLowerCase() === myNick.toLowerCase();
                const cls = isMe ? 'text-yellow-300 font-bold' : 'text-yellow-300';
                return `${pre}<span class="${cls}">@${name}</span>`;
            });
        }

        // Render a message safely, with mention highlighting and optional line highlight when my nick is mentioned
        function renderMessage(who, text) {
            const p = document.createElement('p');
            p.className = 'text-[#00FF00] text-base font-normal leading-normal whitespace-pre-wrap break-words';
            const safeWho = escapeHtml(who || 'Guest');
            let safeText = escapeHtml(text || '');
            safeText = formatMentions(safeText, currentNick);
            p.innerHTML = `[${safeWho}]: ${safeText}`;
            // If my nick is mentioned, add a subtle background to the whole message
            if (currentNick) {
                const meRegex = new RegExp(`(^|\\s)@${escapeRegExp(currentNick)}\\b`, 'i');
                if (meRegex.test(text || '')) {
                    p.classList.add('bg-yellow-900/30');
                }
            }
            return p;
        }

        function setStatus(text, tone = 'yellow') {
            if (!statusPill) return;
            statusPill.textContent = text;
            const map = {
                yellow: ['bg-yellow-700','text-yellow-100'],
                green: ['bg-green-700','text-green-100'],
                red: ['bg-red-700','text-red-100']
            };
            statusPill.className = 'ml-3 inline-block rounded px-2 py-0.5 text-[10px] ' + (map[tone] || map.yellow).join(' ');
        }

        function pruneIfOverflowing() {
            if (!chatMessagesEl) return;
            // 1) Enforce max lines
            while (chatMessagesEl.childElementCount > MAX_HISTORY && chatMessagesEl.firstChild) {
                chatMessagesEl.removeChild(chatMessagesEl.firstChild);
            }
            // 2) Enforce visual overflow (keep removing until fits)
            while (chatMessagesEl.scrollHeight > chatMessagesEl.clientHeight && chatMessagesEl.firstChild) {
                chatMessagesEl.removeChild(chatMessagesEl.firstChild);
            }
        }

        function renderActiveUsers(members) {
            if (!activeUsersListEl) return;
            activeUsersListEl.innerHTML = '';
            (members || []).forEach((m) => {
                const name = (m.clientId || (m.data && m.data.nick) || 'Guest');
                const p = document.createElement('p');
                p.className = 'text-[#00FF00] text-sm';
                p.innerHTML = '<span class="text-green-500">â€¢</span> ' + name;
                activeUsersListEl.appendChild(p);
            });
        }

        function ablyConnect(nick) {
            // If there's an existing client, close it first to avoid duplicate subscriptions
            try {
                if (ably) {
                    try { ably.close(); } catch (_) {}
                    ably = null;
                    ablyChannel = null;
                    ablyAttached = false;
                    messageSubscribed = false;
                    ablyConnected = false;
                }

                // Use Netlify Function to obtain a Token (Token Auth)
                const authUrl = '/.netlify/functions/ably-token?clientId=' + encodeURIComponent(nick);
                ably = new Ably.Realtime({ authUrl });
                setStatus('connecting...', 'yellow');
            } catch (e) {
                const errMsg = createMessageElement('[System]: Failed to initialize Ably client. Falling back to local mode.');
                chatMessagesEl.appendChild(errMsg);
                pruneIfOverflowing();
                return;
            }

            ably.connection.on((stateChange) => {
                if (stateChange.current === 'connected') {
                    ablyConnected = true;
                    setStatus('connected', 'green');
                    ablyChannel = ably.channels.get('public:chat');

                    // Attach explicitly once to catch permission errors
                    if (!ablyAttached) {
                        ablyChannel.attach((attachErr) => {
                            if (attachErr) {
                                setStatus('attach failed', 'red');
                                const err = createMessageElement('[System]: Failed to attach to channel public:chat. Check capabilities / channel restrictions.');
                                chatMessagesEl.appendChild(err);
                                pruneIfOverflowing();
                                return;
                            }

                            ablyAttached = true;

                            // Subscribe to messages only once
                            if (!messageSubscribed) {
                                ablyChannel.subscribe('message', (msg) => {
                                    const payload = msg.data || {};
                                    const who = payload.nick || msg.clientId || 'Guest';
                                    const text = payload.text || '';
                                    if (!text) return;
                                    const line = renderMessage(who, text);
                                    chatMessagesEl.appendChild(line);
                                    pruneIfOverflowing();
                                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                                });
                                messageSubscribed = true;
                            }

                            // Presence: enter once
                            try {
                                ablyChannel.presence.enter({ nick }, (presenceErr) => {
                                    if (presenceErr) {
                                        const er = createMessageElement('[System]: Presence enter failed.');
                                        chatMessagesEl.appendChild(er);
                                        pruneIfOverflowing();
                                    }
                                });
                            } catch (_) {}

                            ablyChannel.presence.get((err, members) => {
                                if (!err) renderActiveUsers(members);
                            });
                            // Update presence list when presence changes
                            ablyChannel.presence.subscribe(() => {
                                ablyChannel.presence.get((err, members) => {
                                    if (!err) renderActiveUsers(members);
                                });
                            });
                        });
                    }

                    // Clean up on unload
                    window.addEventListener('beforeunload', () => {
                        try { ablyChannel && ablyChannel.presence.leave(); } catch (_) {}
                        try { ably && ably.close(); } catch (_) {}
                    });
                } else if (stateChange.current === 'failed' || stateChange.current === 'suspended') {
                    ablyConnected = false;
                    setStatus(stateChange.current, 'red');
                    const msgLine = createMessageElement('[System]: Connection to Ably lost. Messages will be local-only until reconnection.');
                    chatMessagesEl.appendChild(msgLine);
                    pruneIfOverflowing();
                }
            });
        }

        // Fetch public IP (uses api.ipify.org). If it fails, we disable IP enforcement.
        async function fetchIp() {
            try {
                const res = await fetch('https://api.ipify.org?format=json');
                if (!res.ok) throw new Error('IP service error');
                const data = await res.json();
                currentIp = data.ip || null;
                ipCheckAvailable = !!currentIp;
            } catch (err) {
                console.warn('IP check unavailable:', err);
                currentIp = null;
                ipCheckAvailable = false;
            }
        }

        // Persistent storage only for nick+ip (no messages saved)
        function getStored() {
            try {
                const raw = localStorage.getItem('chat_auth');
                return raw ? JSON.parse(raw) : {};
            } catch (e) {
                return {};
            }
        }

        function setStored(obj) {
            try {
                localStorage.setItem('chat_auth', JSON.stringify(obj));
            } catch (e) {
                // ignore
            }
        }

        function disableNickEditing() {
            if (nicknameInput) {
                nicknameInput.setAttribute('readonly', 'true');
                nicknameInput.setAttribute('disabled', 'true');
                nicknameInput.classList.add('opacity-60');
            }
        }

        function enableNickEditing() {
            if (nicknameInput) {
                nicknameInput.removeAttribute('readonly');
                nicknameInput.removeAttribute('disabled');
                nicknameInput.classList.remove('opacity-60');
            }
        }

        function enterChat(nick) {
            if (initialStateEl) initialStateEl.style.display = 'none';
            if (chatMessagesEl) chatMessagesEl.classList.remove('hidden');
            if (messageInputWrapper) messageInputWrapper.classList.remove('hidden');
            if (chatMessagesEl) {
                chatMessagesEl.innerHTML = '';
                const welcome = renderMessage('System', `Welcome, ${nick}!`);
                chatMessagesEl.appendChild(welcome);
                pruneIfOverflowing();
            }
            // Connect to Ably (if configured)
            currentNick = nick;
            ablyConnect(nick);
            messageTextarea && messageTextarea.focus();
        }

        function sendMessage() {
            if (!messageTextarea || !chatMessagesEl) return;
            const text = messageTextarea.value.trim();
            if (!text) return;
            const nick = nicknameInput.value.trim() || 'Guest';
            if (ablyConnected && ablyChannel) {
                // Publish via Ably to broadcast to all
                try {
                    ablyChannel.publish('message', { nick, text }, (err) => {
                        if (err) {
                            const warn = renderMessage('System', 'Publish failed (check channel permissions). Showing locally.');
                            chatMessagesEl.appendChild(warn);
                            pruneIfOverflowing();
                            const msgEl = renderMessage(nick, text);
                            chatMessagesEl.appendChild(msgEl);
                            pruneIfOverflowing();
                            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                        }
                    });
                } catch (_) {
                    // Fallback to local append if publish throws synchronously
                    const msgEl = renderMessage(nick, text);
                    chatMessagesEl.appendChild(msgEl);
                    pruneIfOverflowing();
                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                }
            } else {
                // Local-only mode
                const msgEl = renderMessage(nick, text);
                chatMessagesEl.appendChild(msgEl);
                pruneIfOverflowing();
                chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            }
            messageTextarea.value = '';
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            pruneIfOverflowing();
        }

        // When user attempts to enter with a nickname, enforce the rule
        async function handleEnterAttempt() {
            const nick = (nicknameInput && nicknameInput.value.trim()) || 'Guest';
            // ensure we have IP info
            if (!ipCheckAvailable) {
                // try fetch once more
                await fetchIp();
            }

            const stored = getStored();
            const storedNick = stored.nick || null;
            const storedIp = stored.ip || null;

            // If there is a storedNick and storedIp and IPs match but nick differs -> block change
            if (storedNick && storedIp && ipCheckAvailable && currentIp === storedIp && storedNick !== nick) {
                // Prevent changing nick from same IP
                alert('Nick change is not allowed during the session. To change nick you must reconnect from a different IP.');
                // Revert displayed nick to stored value
                if (nicknameInput) nicknameInput.value = storedNick;
                disableNickEditing();
                // Enter chat with stored nick
                enterChat(storedNick);
                return;
            }

            // Allowed: either no stored info, or IP changed, or same nick
            setStored({ nick: nick, ip: currentIp });
            disableNickEditing();
            enterChat(nick);
        }

        // Init sequence
        (async function init() {
            await fetchIp();
            const stored = getStored();
            const storedNick = stored.nick || '';
            const storedIp = stored.ip || null;

            // If we have stored nick and IP available and IP matches current, prefill and disable editing
            if (storedNick) {
                if (nicknameInput) nicknameInput.value = storedNick;
                if (ipCheckAvailable && storedIp && currentIp === storedIp) {
                    // same IP: cannot change nick -> disable editing and enter chat automatically
                    disableNickEditing();
                    enterChat(storedNick);
                } else {
                    // different IP: allow changing (user reconnect from another IP)
                    enableNickEditing();
                }
            }

            // Wire events
            nicknameInput && nicknameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleEnterAttempt();
                }
            });

            sendButton && sendButton.addEventListener('click', sendMessage);
            messageTextarea && messageTextarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            initialStateEl && initialStateEl.addEventListener('click', () => nicknameInput && nicknameInput.focus());

            // Disable right-click context menu to prevent opening options with mouse button 2
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

        })();

    })();
</script>

</body></html>
