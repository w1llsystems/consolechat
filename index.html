<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Chat App</title>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&amp;display=swap" rel="stylesheet"/>
<style>
        body {
            font-family: 'Space Grotesk', sans-serif;
        }
    </style>
</head>
<body class="bg-black">
<div class="relative flex h-auto min-h-screen w-full flex-col bg-[#111811] dark group/design-root overflow-x-hidden" style='font-family: "Space Grotesk", "Noto Sans", sans-serif;'>
<div class="layout-container flex h-full grow flex-col">
<div class="px-4 py-5 sm:px-10 md:px-20 lg:px-40 flex flex-1 justify-center">
<div class="layout-content-container flex flex-col md:flex-row w-full max-w-6xl flex-1 border-2 border-gray-700 rounded-lg bg-[#0D0D0D] h-[70vh] md:h-[75vh] lg:h-[573px]">
<div class="flex-1 flex flex-col">
<div class="flex items-center justify-between bg-gray-800 px-4 py-2 rounded-t-lg">
<div class="flex items-center gap-2">
<div class="w-3 h-3 bg-red-500 rounded-full"></div>
<div class="w-3 h-3 bg-yellow-500 rounded-full"></div>
<div class="w-3 h-3 bg-green-500 rounded-full"></div>
</div>
<p class="text-gray-400 text-sm">CHAT_APP - bash</p>
<div class="w-12"></div>
</div>
<div class="flex-1 p-4 space-y-4 overflow-y-auto">
<div class="initial-state">
<p class="text-[#00FF00] text-base font-normal leading-normal">Connecting...</p>
<h2 class="text-[#00FF00] tracking-light text-[28px] font-bold leading-tight pt-5">Enter your nickname: _</h2>
</div>
<div class="chat-messages hidden">
<p class="text-[#00FF00] text-base font-normal leading-normal">[System]: Welcome, User_123!</p>
<p class="text-[#00FF00] text-base font-normal leading-normal">[User_123]: Hello world!</p>
</div>
</div>
<div class="p-4 border-t border-gray-700 rounded-bl-lg">
            <div class="nickname-input flex max-w-[320px] flex-wrap items-end gap-2 py-2">
                <label class="flex flex-col min-w-24 flex-1">
                    <input class="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded text-[#00FF00] focus:outline-0 focus:ring-0 border border-[#2A3B2A] bg-[#0D0D0D] focus:border-[#2A3B2A] h-10 placeholder:text-gray-500 p-[8px] text-sm font-normal leading-normal" placeholder="Your nickname" value=""/>
                </label>
            </div>
            <div class="message-input hidden flex flex-wrap items-end gap-2 py-2">
                <label class="flex flex-col flex-1">
                    <textarea class="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded text-[#00FF00] focus:outline-0 focus:ring-0 border border-[#2A3B2A] bg-[#0D0D0D] focus:border-[#2A3B2A] min-h-[64px] placeholder:text-gray-500 p-[8px] text-sm font-normal leading-normal" maxlength="200" placeholder="Type your message (max 200 chars)"></textarea>
                </label>
                <div class="flex justify-start">
                    <button class="flex min-w-[64px] max-w-[160px] cursor-pointer items-center justify-center overflow-hidden rounded h-8 px-3 bg-[#00FF00] text-black text-sm font-bold leading-normal tracking-[0.015em]" type="button">
                        <span class="truncate">Send</span>
                    </button>
                </div>
            </div>
</div>
</div>
<div class="w-full md:w-[240px] border-t-2 md:border-t-0 md:border-l-2 border-gray-700 flex flex-col">
<div class="bg-gray-800 px-4 py-2 flex items-center justify-center">
<p class="text-gray-400 text-sm">ACTIVE_USERS</p>
</div>
<div id="active-users-list" class="p-4 space-y-2 overflow-y-auto max-h-40 md:max-h-none flex-1"></div>
</div>
</div>
</div>
</div>
</div>

<script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
<script>
    // Minimal client-side anonymous chat behavior
    // - No persistence (no localStorage/sessionStorage)
    // - User supplies a nickname (optional)
    // - Messages are appended locally only
    // - When the messages container overflows, oldest messages are removed so the layout stays clean

    (function () {
        const initialStateEl = document.querySelector('.initial-state');
        const chatMessagesEl = document.querySelector('.chat-messages');
        const nicknameInput = document.querySelector('.nickname-input input');
        const messageInputWrapper = document.querySelector('.message-input');
        const messageTextarea = document.querySelector('.message-input textarea');
        const sendButton = document.querySelector('.message-input button');
        const activeUsersListEl = document.querySelector('#active-users-list');

        // Make sure button acts as button
        if (sendButton) sendButton.setAttribute('type', 'button');

        // State
        let currentIp = null;
        let ipCheckAvailable = false;
    let ably = null;
        let ablyChannel = null;
        let ablyConnected = false;

        // Helpers
        function createMessageElement(text) {
            const p = document.createElement('p');
            p.className = 'text-[#00FF00] text-base font-normal leading-normal';
            p.textContent = text;
            return p;
        }

        function pruneIfOverflowing() {
            while (chatMessagesEl && chatMessagesEl.scrollHeight > chatMessagesEl.clientHeight && chatMessagesEl.firstChild) {
                chatMessagesEl.removeChild(chatMessagesEl.firstChild);
            }
        }

        function renderActiveUsers(members) {
            if (!activeUsersListEl) return;
            activeUsersListEl.innerHTML = '';
            (members || []).forEach((m) => {
                const name = (m.clientId || (m.data && m.data.nick) || 'Guest');
                const p = document.createElement('p');
                p.className = 'text-[#00FF00] text-sm';
                p.innerHTML = '<span class="text-green-500">â€¢</span> ' + name;
                activeUsersListEl.appendChild(p);
            });
        }

        function ablyConnect(nick) {
            try {
                // Use Netlify Function to obtain a Token (Token Auth)
                const authUrl = '/.netlify/functions/ably-token?clientId=' + encodeURIComponent(nick);
                ably = new Ably.Realtime({ authUrl });
            } catch (e) {
                const errMsg = createMessageElement('[System]: Failed to initialize Ably client. Falling back to local mode.');
                chatMessagesEl.appendChild(errMsg);
                pruneIfOverflowing();
                return;
            }

            ably.connection.on((stateChange) => {
                if (stateChange.current === 'connected') {
                    ablyConnected = true;
                    ablyChannel = ably.channels.get('public:chat');

                    // Subscribe to messages
                    ablyChannel.subscribe('message', (msg) => {
                        const payload = msg.data || {};
                        const who = payload.nick || msg.clientId || 'Guest';
                        const text = payload.text || '';
                        if (!text) return;
                        const line = createMessageElement(`[${who}]: ${text}`);
                        chatMessagesEl.appendChild(line);
                        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                        pruneIfOverflowing();
                    });

                    // Presence
                    ablyChannel.presence.enter({ nick });
                    ablyChannel.presence.get((err, members) => {
                        if (!err) renderActiveUsers(members);
                    });
                    ablyChannel.presence.subscribe((presenceMsg) => {
                        ablyChannel.presence.get((err, members) => {
                            if (!err) renderActiveUsers(members);
                        });
                    });

                    // Clean up on unload
                    window.addEventListener('beforeunload', () => {
                        try { ablyChannel && ablyChannel.presence.leave(); } catch (_) {}
                    });
                } else if (stateChange.current === 'failed' || stateChange.current === 'suspended') {
                    ablyConnected = false;
                    const msg = createMessageElement('[System]: Connection to Ably lost. Messages will be local-only until reconnection.');
                    chatMessagesEl.appendChild(msg);
                    pruneIfOverflowing();
                }
            });
        }

        // Fetch public IP (uses api.ipify.org). If it fails, we disable IP enforcement.
        async function fetchIp() {
            try {
                const res = await fetch('https://api.ipify.org?format=json');
                if (!res.ok) throw new Error('IP service error');
                const data = await res.json();
                currentIp = data.ip || null;
                ipCheckAvailable = !!currentIp;
            } catch (err) {
                console.warn('IP check unavailable:', err);
                currentIp = null;
                ipCheckAvailable = false;
            }
        }

        // Persistent storage only for nick+ip (no messages saved)
        function getStored() {
            try {
                const raw = localStorage.getItem('chat_auth');
                return raw ? JSON.parse(raw) : {};
            } catch (e) {
                return {};
            }
        }

        function setStored(obj) {
            try {
                localStorage.setItem('chat_auth', JSON.stringify(obj));
            } catch (e) {
                // ignore
            }
        }

        function disableNickEditing() {
            if (nicknameInput) {
                nicknameInput.setAttribute('readonly', 'true');
                nicknameInput.setAttribute('disabled', 'true');
                nicknameInput.classList.add('opacity-60');
            }
        }

        function enableNickEditing() {
            if (nicknameInput) {
                nicknameInput.removeAttribute('readonly');
                nicknameInput.removeAttribute('disabled');
                nicknameInput.classList.remove('opacity-60');
            }
        }

        function enterChat(nick) {
            if (initialStateEl) initialStateEl.style.display = 'none';
            if (chatMessagesEl) chatMessagesEl.classList.remove('hidden');
            if (messageInputWrapper) messageInputWrapper.classList.remove('hidden');
            if (chatMessagesEl) {
                chatMessagesEl.innerHTML = '';
                const welcome = createMessageElement(`[System]: Welcome, ${nick}!`);
                chatMessagesEl.appendChild(welcome);
                pruneIfOverflowing();
            }
            // Connect to Ably (if configured)
            ablyConnect(nick);
            messageTextarea && messageTextarea.focus();
        }

        function sendMessage() {
            if (!messageTextarea || !chatMessagesEl) return;
            const text = messageTextarea.value.trim();
            if (!text) return;
            const nick = nicknameInput.value.trim() || 'Guest';
            if (ablyConnected && ablyChannel) {
                // Publish via Ably to broadcast to all
                try {
                    ablyChannel.publish('message', { nick, text });
                } catch (_) {
                    // Fallback to local append if publish fails
                    const msg = createMessageElement(`[${nick}]: ${text}`);
                    chatMessagesEl.appendChild(msg);
                }
            } else {
                // Local-only mode
                const msg = createMessageElement(`[${nick}]: ${text}`);
                chatMessagesEl.appendChild(msg);
            }
            messageTextarea.value = '';
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
            pruneIfOverflowing();
        }

        // When user attempts to enter with a nickname, enforce the rule
        async function handleEnterAttempt() {
            const nick = (nicknameInput && nicknameInput.value.trim()) || 'Guest';
            // ensure we have IP info
            if (!ipCheckAvailable) {
                // try fetch once more
                await fetchIp();
            }

            const stored = getStored();
            const storedNick = stored.nick || null;
            const storedIp = stored.ip || null;

            // If there is a storedNick and storedIp and IPs match but nick differs -> block change
            if (storedNick && storedIp && ipCheckAvailable && currentIp === storedIp && storedNick !== nick) {
                // Prevent changing nick from same IP
                alert('Nick change is not allowed during the session. To change nick you must reconnect from a different IP.');
                // Revert displayed nick to stored value
                if (nicknameInput) nicknameInput.value = storedNick;
                disableNickEditing();
                // Enter chat with stored nick
                enterChat(storedNick);
                return;
            }

            // Allowed: either no stored info, or IP changed, or same nick
            setStored({ nick: nick, ip: currentIp });
            disableNickEditing();
            enterChat(nick);
        }

        // Init sequence
        (async function init() {
            await fetchIp();
            const stored = getStored();
            const storedNick = stored.nick || '';
            const storedIp = stored.ip || null;

            // If we have stored nick and IP available and IP matches current, prefill and disable editing
            if (storedNick) {
                if (nicknameInput) nicknameInput.value = storedNick;
                if (ipCheckAvailable && storedIp && currentIp === storedIp) {
                    // same IP: cannot change nick -> disable editing and enter chat automatically
                    disableNickEditing();
                    enterChat(storedNick);
                } else {
                    // different IP: allow changing (user reconnect from another IP)
                    enableNickEditing();
                }
            }

            // Wire events
            nicknameInput && nicknameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleEnterAttempt();
                }
            });

            sendButton && sendButton.addEventListener('click', sendMessage);
            messageTextarea && messageTextarea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            initialStateEl && initialStateEl.addEventListener('click', () => nicknameInput && nicknameInput.focus());

        })();

    })();
</script>

</body></html>
